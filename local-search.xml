<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/1e8e16225a6a.html"/>
    <url>/2023/03/1e8e16225a6a.html</url>
    
    <content type="html"><![CDATA[<h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><p>父子组件通信是指，Child 组件引入到 Father 组件里渲染，此时 Father 是 Child 的父级；Child 组件的一些数据需要从 Father 组件拿，Child 组件有时也要告知 Father 组件一些数据变化情况。</p><p>他们之间的关系如下， Child.vue 是直接挂载在 Father.vue 下面：</p><p>bash</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 父组件</span><br>Father.vue<br>│ <span class="hljs-meta"># 子组件</span><br>└─Child.vue<br></code></pre></td></tr></table></figure><p>常用的方法有：</p><table><thead><tr><th align="left">方案</th><th align="left">父组件向子组件</th><th align="left">子组件向父组件</th></tr></thead><tbody><tr><td align="left">props &#x2F; emits</td><td align="left">props</td><td align="left">emits</td></tr><tr><td align="left">v-model &#x2F; emits</td><td align="left">v-model</td><td align="left">emits</td></tr><tr><td align="left">ref &#x2F; emits</td><td align="left">ref</td><td align="left">emits</td></tr><tr><td align="left">provide &#x2F; inject</td><td align="left">provide</td><td align="left">inject</td></tr><tr><td align="left">EventBus</td><td align="left">emit &#x2F; on</td><td align="left">emit &#x2F; on</td></tr><tr><td align="left">Reative State</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">Vuex</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">Pinia</td><td align="left">-</td><td align="left">-</td></tr></tbody></table><h2 id="爷孙组件通信"><a href="#爷孙组件通信" class="headerlink" title="爷孙组件通信"></a>爷孙组件通信</h2><p>顾名思义，爷孙组件是比 <a href="https://vue3.chengpeiquan.com/communication.html#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1">父子组件通信</a> 要更深层次的引用关系（也有称之为 “隔代组件” ）。</p><p>C 组件被引入到 B 组件里， B 组件又被引入到 A 组件里渲染，此时 A 是 C 的爷爷级别（可能还有更多层级关系），它们之间的关系可以假设如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Grandfather</span>.</span></span>vue<br>└─<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Son</span>.</span></span>vue<br>  └─<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Grandson</span>.</span></span>vue<br></code></pre></td></tr></table></figure><p>可以看到 Grandson.vue 并非直接挂载在 Grandfather.vue 下面，他们之间还隔着至少一个 Son.vue （在实际业务中可能存在更多层级），如果使用 props ，只能一级组件一级组件传递下去，就太繁琐了。</p><p><img src="https://vue3.chengpeiquan.com/assets/img/communication-prop-drilling.png" alt="Props 的多级传递会非常繁琐（摘自 Vue 官网）"></p><p>Props 的多级传递会非常繁琐（摘自 Vue 官网）</p><p>因此需要更直接的通信方式来解决这种问题，这一 Part 就是讲一讲 C 和 A 之间的数据传递，常用的方法有：</p><table><thead><tr><th align="left">方案</th><th align="left">爷组件向孙组件</th><th align="left">孙组件向爷组件</th><th align="left">对应章节传送门</th></tr></thead><tbody><tr><td align="left">provide &#x2F; inject</td><td align="left">provide</td><td align="left">inject</td><td align="left"><a href="https://vue3.chengpeiquan.com/communication.html#provide-inject">点击查看</a></td></tr><tr><td align="left">EventBus</td><td align="left">emit &#x2F; on</td><td align="left">emit &#x2F; on</td><td align="left"><a href="https://vue3.chengpeiquan.com/communication.html#eventbus-new">点击查看</a></td></tr><tr><td align="left">Reative State</td><td align="left">-</td><td align="left">-</td><td align="left"><a href="https://vue3.chengpeiquan.com/communication.html#reative-state-new">点击查看</a></td></tr><tr><td align="left">Vuex</td><td align="left">-</td><td align="left">-</td><td align="left"><a href="https://vue3.chengpeiquan.com/communication.html#vuex-new">点击查看</a></td></tr><tr><td align="left">Pinia</td><td align="left">-</td><td align="left">-</td><td align="left"><a href="https://vue3.chengpeiquan.com/pinia.html">点击查看</a></td></tr></tbody></table><p>因为上下级的关系的一致性，爷孙组件通信的方案也适用于 <a href="https://vue3.chengpeiquan.com/communication.html#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1">父子组件通信</a> ，只需要把爷孙关系换成父子关系即可，为了方便阅读，下面的爷组件统一叫 Grandfather.vue，子组件统一叫 Grandson.vue 。</p><h2 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信#"></a>兄弟组件通信<a href="https://vue3.chengpeiquan.com/communication.html#%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1">#</a></h2><p>兄弟组件是指两个组件都挂载在同一个 Father.vue 下，但两个组件之间并没有什么直接的关联，先看看它们的关系：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Father</span>.</span></span>vue<br>├─<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Brother</span>.</span></span>vue<br>└─<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LittleBrother</span>.</span></span>vue<br></code></pre></td></tr></table></figure><p>这种层级关系下，如果组件之间要进行通信，目前通常有这两类选择：</p><ol><li>【不推荐】先把数据传给 Father.vue ，再使用 <a href="https://vue3.chengpeiquan.com/communication.html#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1">父子组件通信</a> 方案处理</li><li>【推荐】借助 <a href="https://vue3.chengpeiquan.com/communication.html#%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1">全局组件通信</a> 的方案达到目的</li></ol><p>下面的内容将进入全局通信的讲解。</p><h2 id="全局组件通信"><a href="#全局组件通信" class="headerlink" title="全局组件通信#"></a>全局组件通信<a href="https://vue3.chengpeiquan.com/communication.html#%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1">#</a></h2><p>全局组件通信是指项目下两个任意组件，不管是否有直接关联（例如父子关系、爷孙关系）都可以直接进行交流的通信方案。</p><p>举个例子，像下面这种项目结构， B2.vue 可以采用全局通信方案直接向 D2.vue 发起交流，而无需经过它们各自的父组件。</p><p>bash</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>vue<br>├─<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B1</span>.</span></span>vue<br>├───<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">C1</span>.</span></span>vue<br>├─────<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">D1</span>.</span></span>vue<br>├─────<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">D2</span>.</span></span>vue<br>├───<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">C2</span>.</span></span>vue<br>├─────<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">D3</span>.</span></span>vue<br>└─<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B2</span>.</span></span>vue<br></code></pre></td></tr></table></figure><p>常用的方法有：</p><table><thead><tr><th align="left">方案</th><th align="left">发起方</th><th align="left">接收方</th><th align="left">对应章节传送门</th></tr></thead><tbody><tr><td align="left">EventBus</td><td align="left">emit</td><td align="left">on</td><td align="left"><a href="https://vue3.chengpeiquan.com/communication.html#eventbus-new">点击查看</a></td></tr><tr><td align="left">Reative State</td><td align="left">-</td><td align="left">-</td><td align="left"><a href="https://vue3.chengpeiquan.com/communication.html#reative-state-new">点击查看</a></td></tr><tr><td align="left">Vuex</td><td align="left">-</td><td align="left">-</td><td align="left"><a href="https://vue3.chengpeiquan.com/communication.html#vuex-new">点击查看</a></td></tr><tr><td align="left">Pinia</td><td align="left">-</td><td align="left">-</td><td align="left"><a href="https://vue3.chengpeiquan.com/pinia.html">点击查看</a></td></tr></tbody></table><h2 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus#"></a>EventBus<a href="https://vue3.chengpeiquan.com/communication.html#eventbus-new">#</a></h2><p>EventBus 通常被称之为 “全局事件总线” ，是用在全局范围内通信的一个常用方案，在 Vue 2 时期该方案非常流行，其特点就是 “简单” 、 “灵活” 、 “轻量级” 。</p><h2 id="Reative-State"><a href="#Reative-State" class="headerlink" title="Reative State"></a>Reative State</h2><p>在 Vue 3 里，使用响应式的 reative API 也可以实现一个小型的状态共享库，如果运用在一个简单的 H5 活动页面这样小需求里，完全可以满足使用。</p><p>Sorce: <a href="https://vue3.chengpeiquan.com/communication.html">组件之间的通信 | Vue3 入门指南与实战案例 (chengpeiquan.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue Basic</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/03/6306fc9f91f4.html"/>
    <url>/2023/03/6306fc9f91f4.html</url>
    
    <content type="html"><![CDATA[<h3 id="路由里的全局钩子"><a href="#路由里的全局钩子" class="headerlink" title="路由里的全局钩子"></a>路由里的全局钩子</h3><p>顾名思义，是在创建 <code>router</code> 的时候进行全局的配置，也就是说，只要配置了钩子，那么所有的路由在被访问到的时候，都会触发这些钩子函数。</p><table><thead><tr><th style="text-align:left;">可用钩子</th><th style="text-align:left;">含义</th><th style="text-align:left;">触发时机</th></tr></thead><tbody><tr><td style="text-align:left;">beforeEach</td><td style="text-align:left;">全局前置守卫</td><td style="text-align:left;">在路由跳转前触发</td></tr><tr><td style="text-align:left;">beforeResolve</td><td style="text-align:left;">全局解析守卫</td><td style="text-align:left;">在导航被确认前，同时在组件内守卫和异步路由组件被解析后</td></tr><tr><td style="text-align:left;">afterEach</td><td style="text-align:left;">全局后置守卫</td><td style="text-align:left;">在路由跳转完成后触发</td></tr></tbody></table>#### beforeEach1. 比如在进入路由之前，根据 Meta 路由元信息的配置，设定路由的网页标题   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; title &#125; = to.<span class="hljs-property">meta</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = title || <span class="hljs-string">&#x27;默认标题&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li><p>判断是否需要登录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; isNoLogin &#125; = to.<span class="hljs-property">meta</span><br>  <span class="hljs-keyword">if</span> (!isNoLogin) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;/login&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>针对一些需要 ID 参数，但参数丢失的路由做拦截，比如：很多网站的文章详情页都是类似 <code>https://example.com/article/123</code> 这样格式的地址，是需要带有文章 ID 作为 URL 的一部分，如果只访问 <code>https://example.com/article</code> 则需要拦截掉。</p></li></ol><h4 id="beforeResolve"><a href="#beforeResolve" class="headerlink" title="beforeResolve"></a>beforeResolve</h4><ol><li><p>它通常会用在一些申请权限的环节，比如一些 H5 页面需要申请系统相机权限、一些微信活动需要申请微信的登录信息授权，获得权限之后才允许获取接口数据和给用户更多的操作，使用 <code>beforeEach</code> 时机太早，使用 <code>afterEach</code> 又有点晚，那么这个钩子的时机就刚刚好。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// https://router.vuejs.org/zh/guide/advanced/navigation-guards.html</span><br><br>router.<span class="hljs-title function_">beforeResolve</span>(<span class="hljs-keyword">async</span> (to) =&gt; &#123;<br>  <span class="hljs-comment">// 如果路由配置了必须调用相机权限</span><br>  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>.<span class="hljs-property">requiresCamera</span>) &#123;<br>    <span class="hljs-comment">// 正常流程，咨询是否允许使用照相机</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">askForCameraPermission</span>()<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-comment">// 容错</span><br>      <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">NotAllowedError</span>) &#123;<br>        <span class="hljs-comment">// ... 处理错误，然后取消导航</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果出现意外，则取消导航并抛出错误</span><br>        <span class="hljs-keyword">throw</span> error<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><h4 id="afterEach"><a href="#afterEach" class="headerlink" title="afterEach"></a>afterEach</h4><ol><li>在刚刚的 <a href="https://vue3.chengpeiquan.com/router.html#%E9%92%A9%E5%AD%90%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">钩子的应用场景</a> 里面有个例子，就是每次切换路由都上报一次 PV 数据，类似这种每个路由都要执行一次，但又不必在渲染前操作的，都可以放到后置钩子里去执行。</li></ol><h3 id="路由里的独享钩子"><a href="#路由里的独享钩子" class="headerlink" title="路由里的独享钩子"></a>路由里的独享钩子</h3><p>如果只是有个别路由要做处理，可以使用路由独享的守卫，用来针对个别路由定制一些特殊功能，可以减少在全局钩子里面写一堆判断。</p><table><thead><tr><th align="left">可用钩子</th><th align="left">含义</th><th align="left">触发时机</th></tr></thead><tbody><tr><td align="left">beforeEnter</td><td align="left">路由独享前置守卫</td><td align="left">在路由跳转前触发</td></tr></tbody></table><p>注：路由独享的钩子，必须配置在 <code>routes</code> 的 JSON 树里面，挂在对应的路由下面（与 <code>path</code>、 <code>name</code>、<code>meta</code> 这些字段同级）。</p><h4 id="beforeEnter"><a href="#beforeEnter" class="headerlink" title="beforeEnter"></a>beforeEnter</h4><p>它和全局钩子 <code>beforeEach</code> 的作用相同，都是在进入路由之前触发，触发时机比 <code>beforeResolve</code> 要早。</p><p>顺序：<code>beforeEach</code>（全局） &gt; <code>beforeEnter</code>（独享） &gt; <code>beforeResolve</code>（全局）。</p><ol><li><p>整个站点的默认标题都是以 “栏目标题” + “全站关键标题” 的格式作为网页的 Title ，例如 “项目经验 - hf” ，但在首页的时候，想做一些不一样的定制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">RouteRecordRaw</span>&gt; = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@views/home.vue&#x27;</span>),<br>    <span class="hljs-comment">// 在这里添加单独的路由守卫</span><br>    <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;hf - 养了三只猫&#x27;</span><br>    &#125;,<br>  &#125;,<br>]<br></code></pre></td></tr></table></figure></li></ol><h3 id="组件内单独使用"><a href="#组件内单独使用" class="headerlink" title="组件内单独使用"></a>组件内单独使用</h3><p>组件里除了可以使用全局钩子外，还可以使用组件专属的路由钩子。</p><table><thead><tr><th align="left">可用钩子</th><th align="left">含义</th><th align="left">触发时机</th></tr></thead><tbody><tr><td align="left">onBeforeRouteUpdate</td><td align="left">组件内的更新守卫</td><td align="left">在当前路由改变，但是该组件被复用时调用</td></tr><tr><td align="left">onBeforeRouteLeave</td><td align="left">组件内的离开守卫</td><td align="left">导航离开该组件的对应路由时调用</td></tr></tbody></table><h4 id="onBeforeRouteUpdate"><a href="#onBeforeRouteUpdate" class="headerlink" title="onBeforeRouteUpdate"></a>onBeforeRouteUpdate</h4><p>一个内容网站，通常在文章详情页底部会有相关阅读推荐，这个时候就会有一个操作场景是，从文章 A 跳转到文章 B。</p><p>比如从 <code>https://example.com/article/111</code> 切去 <code>https://example.com/article/222</code> ，这种情况就属于 “路由改变，但是组件被复用” 的情况了。</p><p>这种情况下，原本放在 <code>onMounted</code> 里执行数据请求的函数就不会被调用，可以借助该钩子来实现渲染新的文章内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineComponent, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; useRoute, onBeforeRouteUpdate &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 其他代码略...</span><br><br>    <span class="hljs-comment">// 查询文章详情</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">queryArticleDetail</span>(<span class="hljs-params">id: number</span>) &#123;<br>      <span class="hljs-comment">// 请求接口数据</span><br>      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">`/article/<span class="hljs-subst">$&#123;id&#125;</span>`</span>,<br>      &#125;)<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-comment">// 组件挂载完成后执行文章内容的请求</span><br>    <span class="hljs-comment">// 注意这里是获取 `route` 的 `params`</span><br>    <span class="hljs-title function_">onMounted</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>      <span class="hljs-keyword">const</span> id = <span class="hljs-title class_">Number</span>(route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>) || <span class="hljs-number">0</span><br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryArticleDetail</span>(id)<br>    &#125;)<br><br>    <span class="hljs-comment">// 组件被复用时重新请求新的文章内容</span><br>    <span class="hljs-title function_">onBeforeRouteUpdate</span>(<span class="hljs-keyword">async</span> (to, <span class="hljs-keyword">from</span>) =&gt; &#123;<br>      <span class="hljs-comment">// ID 不变时减少重复请求</span><br>      <span class="hljs-keyword">if</span> (to.<span class="hljs-property">params</span>.<span class="hljs-property">id</span> === <span class="hljs-keyword">from</span>.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>) <span class="hljs-keyword">return</span><br><br>      <span class="hljs-comment">// 注意这里是获取 `to` 的 `params`</span><br>      <span class="hljs-keyword">const</span> id = <span class="hljs-title class_">Number</span>(to.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>) || <span class="hljs-number">0</span><br>      <span class="hljs-keyword">await</span> <span class="hljs-title function_">queryArticleDetail</span>(id)<br>    &#125;)<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="onBeforeRouteLeave"><a href="#onBeforeRouteLeave" class="headerlink" title="onBeforeRouteLeave"></a>onBeforeRouteLeave</h4><ol><li><p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开，可以通过 <code>return false</code> 来取消用户离开当前路由。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; onBeforeRouteLeave &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 调用离开守卫</span><br>    <span class="hljs-title function_">onBeforeRouteLeave</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 弹出一个确认框</span><br>      <span class="hljs-keyword">const</span> confirmText = <span class="hljs-string">&#x27;确认要离开吗？您的更改尚未保存！&#x27;</span><br>      <span class="hljs-keyword">const</span> isConfirmLeave = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">confirm</span>(confirmText)<br><br>      <span class="hljs-comment">// 当用户点取消时，不离开路由</span><br>      <span class="hljs-keyword">if</span> (!isConfirmLeave) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      &#125;<br>    &#125;)<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>VueRouter</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2023/03/581bebdce476.html"/>
    <url>/2023/03/581bebdce476.html</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-x2F-IP-网络模型有哪几层？"><a href="#TCP-x2F-IP-网络模型有哪几层？" class="headerlink" title="TCP&#x2F;IP 网络模型有哪几层？"></a>TCP&#x2F;IP 网络模型有哪几层？</h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。<br>应用层是不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。</p><p>而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>应用层的数据包会传给传输层，<strong>传输层</strong>是为应用层提供网络支持的。<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E5%BA%94%E7%94%A8%E5%B1%82.png"><br>TCP&#x2F;UDP</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>IP 协议（_Internet Protocol_）</p><h2 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h2><p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（_Link Layer_）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p><h1 id="键入网址到网页显示，期间发生了什么？"><a href="#键入网址到网页显示，期间发生了什么？" class="headerlink" title="键入网址到网页显示，期间发生了什么？"></a>键入网址到网页显示，期间发生了什么？</h1><ol><li>HTTP 请求</li><li>DNS 解析</li><li>TCP 传输</li><li>IP 定位</li></ol><h1 id="HTTP-相关"><a href="#HTTP-相关" class="headerlink" title="HTTP 相关"></a>HTTP 相关</h1><p><img src="https://cdn.xiaolincoding.com//mysql/other/6b9bfd38d2684b3f9843ebabf8771212.png" alt="提纲"></p><h1 id="TCP-相关"><a href="#TCP-相关" class="headerlink" title="TCP 相关"></a>TCP 相关</h1><p><img src="https://cdn.xiaolincoding.com//mysql/other/1310bf5ed78e4c8186481c47719e0793.png"></p><h1 id="IP-相关"><a href="#IP-相关" class="headerlink" title="IP 相关"></a>IP 相关</h1><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/1.jpg" alt="IP 基础知识全家桶"></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态路由</title>
    <link href="/2023/03/9771e484b89a.html"/>
    <url>/2023/03/9771e484b89a.html</url>
    
    <content type="html"><![CDATA[<h1 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h1><h3 id="1-1-基于角色添加路由"><a href="#1-1-基于角色添加路由" class="headerlink" title="1.1. 基于角色添加路由"></a>1.1. 基于角色添加路由</h3><p>定义一个枚举类或者对象，将角色和其能访问的路由进行绑定。</p><p>缺点：每增加一个角色，都要增加 key&#x2F;value，并且需要重新发布或者从后端返回 JSON</p><h3 id="1-2-基于菜单动态匹配（-）"><a href="#1-2-基于菜单动态匹配（-）" class="headerlink" title="1.2. 基于菜单动态匹配（*）"></a>1.2. 基于菜单动态匹配（*）</h3><p>没有权限就没有对应的菜单，<strong>把菜单映射成路由对象</strong>。</p><p>将 views 和动态路由对应起来，以便自动化处理</p><h3 id="1-3-动态创建页面和路由对象"><a href="#1-3-动态创建页面和路由对象" class="headerlink" title="1.3. 动态创建页面和路由对象"></a>1.3. 动态创建页面和路由对象</h3><p>自动化添加：coderwhy add3page_setup {pagename} -d {path} （保证Router 和 Views 对应一致）</p><h3 id="1-4-从文件中读取所有的路由"><a href="#1-4-从文件中读取所有的路由" class="headerlink" title="1.4. 从文件中读取所有的路由"></a>1.4. 从文件中读取所有的路由</h3><ul><li>localRoutes</li></ul><h3 id="1-5-根据菜单动态的映射路由"><a href="#1-5-根据菜单动态的映射路由" class="headerlink" title="1.5. 根据菜单动态的映射路由"></a>1.5. 根据菜单动态的映射路由</h3><ul><li>routes</li><li>router.addRoute(‘main’, xxxx)</li></ul><h3 id="1-6-刷新保持路由的注册状态"><a href="#1-6-刷新保持路由的注册状态" class="headerlink" title="1.6. 刷新保持路由的注册状态"></a>1.6. 刷新保持路由的注册状态</h3><h3 id="1-7-登录进入匹配第一个页面"><a href="#1-7-登录进入匹配第一个页面" class="headerlink" title="1.7. 登录进入匹配第一个页面"></a>1.7. 登录进入匹配第一个页面</h3><h3 id="1-8-刷新页面根据路径匹配menu菜单"><a href="#1-8-刷新页面根据路径匹配menu菜单" class="headerlink" title="1.8. 刷新页面根据路径匹配menu菜单"></a>1.8. 刷新页面根据路径匹配menu菜单</h3><h3 id="1-9-面包屑的功能实现"><a href="#1-9-面包屑的功能实现" class="headerlink" title="1.9. 面包屑的功能实现"></a>1.9. 面包屑的功能实现</h3><p>点击面包屑实现路由跳转，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-breadcrumb</span> <span class="hljs-attr">separator-icon</span>=<span class="hljs-string">&quot;CaretRight&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in breadcrumbs&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.name&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">el-breadcrumb-item</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;item.path&quot;</span>&gt;</span><br>          &#123;&#123; item.name &#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">el-breadcrumb-item</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-breadcrumb</span>&gt;</span><br></code></pre></td></tr></table></figure><p>「」</p>]]></content>
    
    
    <categories>
      
      <category>前端项目</category>
      
      <category>CMS 项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用户管理</title>
    <link href="/2023/03/18a6def6cce0.html"/>
    <url>/2023/03/18a6def6cce0.html</url>
    
    <content type="html"><![CDATA[<h2 id="用户User界面"><a href="#用户User界面" class="headerlink" title="用户User界面"></a>用户User界面</h2><h3 id="3-1-search搜索区域的布局"><a href="#3-1-search搜索区域的布局" class="headerlink" title="3.1. search搜索区域的布局"></a>3.1. search搜索区域的布局</h3><p>elementUI 国际化 -&gt;包裹 Routerview</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-config-provider</span> <span class="hljs-attr">:locale</span>=<span class="hljs-string">&quot;zhCn&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-config-provider</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> zhCn <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus/dist/locale/zh-cn.mjs&#x27;</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-2-content的整体布局"><a href="#3-2-content的整体布局" class="headerlink" title="3.2. content的整体布局"></a>3.2. content的整体布局</h3><h3 id="3-3-获取user的数据展示"><a href="#3-3-获取user的数据展示" class="headerlink" title="3.3. 获取user的数据展示"></a>3.3. 获取user的数据展示</h3><ul><li>el-table展示</li><li>自定义column</li></ul><h3 id="3-4-自定义Table的Column"><a href="#3-4-自定义Table的Column" class="headerlink" title="3.4. 自定义Table的Column"></a>3.4. 自定义Table的Column</h3><ul><li><p>作用域插槽，scope 能接受传来的一整行的属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 作用域插槽 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">&quot;scope&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:type</span>=<span class="hljs-string">&quot;scope.row.enable ? &#x27;primary&#x27; : &#x27;danger&#x27;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">plain</span></span><br><span class="hljs-tag">  &gt;</span><br>    &#123;&#123; scope.row.enable ? &#x27;启用&#x27; : &#x27;禁用&#x27; &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>enable</p></li><li><p>createAt&#x2F;updateAt</p><ul><li>dayjs封装utc转换（或者重量级的库 momentjs）</li></ul></li></ul><h3 id="3-5-分页pagination组件展示"><a href="#3-5-分页pagination组件展示" class="headerlink" title="3.5. 分页pagination组件展示"></a>3.5. 分页pagination组件展示</h3><h3 id="3-6-页码改变-x2F-点击查询-x2F-重置-发送网络请求"><a href="#3-6-页码改变-x2F-点击查询-x2F-重置-发送网络请求" class="headerlink" title="3.6. 页码改变&#x2F;点击查询&#x2F;重置 - 发送网络请求"></a>3.6. 页码改变&#x2F;点击查询&#x2F;重置 - 发送网络请求</h3><p>查询的实现：</p><ol><li>search 组件拿到 input 里面的值触发handleQueryClick事件</li><li>content 组件向父组件暴露一个fetchUserListData</li><li>父组件 user 调用 conten 暴露的 fetchUserListData 获取查询的值</li></ol><h3 id="3-7-删除某一条数据"><a href="#3-7-删除某一条数据" class="headerlink" title="3.7. 删除某一条数据"></a>3.7. 删除某一条数据</h3><p>删除完一条数据一定要重新 fetch 一下数据~</p><h3 id="3-8-新建用户的Modal"><a href="#3-8-新建用户的Modal" class="headerlink" title="3.8. 新建用户的Modal"></a>3.8. 新建用户的Modal</h3><ul><li>user-modal.vue组件 要写到 user.vue里</li><li>布局组件</li><li>点击确定按钮, user-modal 和 user-content 进行兄弟组件通信<ul><li>usercontent emit 一个事件</li><li>user 监听这个事件并拿到这个兄弟组件（用 ref 得到他）并调用 他的user-model expose 的方法（原理同查询的实现）</li></ul></li></ul><p>要注意部门信息要提前加载，创建完也一定要重新 fetch 一下数据</p><h3 id="3-9-编辑用户的Modal"><a href="#3-9-编辑用户的Modal" class="headerlink" title="3.9. 编辑用户的Modal"></a>3.9. 编辑用户的Modal</h3><ul><li>编辑的数据, 进行回显</li><li>编辑操作网络请求</li></ul><h2 id="三-页面的重构（重构代码是一件痛苦的过程）"><a href="#三-页面的重构（重构代码是一件痛苦的过程）" class="headerlink" title="三. 页面的重构（重构代码是一件痛苦的过程）"></a>三. 页面的重构（重构代码是一件痛苦的过程）</h2><h3 id="3-1-组件进行拷贝"><a href="#3-1-组件进行拷贝" class="headerlink" title="3.1. 组件进行拷贝"></a>3.1. 组件进行拷贝</h3><ul><li>修改它的网络请求的部分</li><li>store&#x2F;service</li></ul><h3 id="3-2-组件进行配置"><a href="#3-2-组件进行配置" class="headerlink" title="3.2. 组件进行配置"></a>3.2. 组件进行配置</h3><ul><li>page-search的配置</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端项目</category>
      
      <category>CMS 项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>登录路由</title>
    <link href="/2023/03/67c7e7a59f89.html"/>
    <url>/2023/03/67c7e7a59f89.html</url>
    
    <content type="html"><![CDATA[<h1 id="一-登录页面的功能"><a href="#一-登录页面的功能" class="headerlink" title="一. 登录页面的功能"></a>一. 登录页面的功能</h1><h3 id="1-1-导航守卫"><a href="#1-1-导航守卫" class="headerlink" title="1.1. 导航守卫"></a>1.1. 导航守卫</h3><p>使用导航守卫进行拦截，而不是简单使用 redirect。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 只有登录成功(token), 才能真正进入到main页面</span><br>  <span class="hljs-keyword">const</span> token = localCache.<span class="hljs-title function_">getCache</span>(<span class="hljs-variable constant_">LOGIN_TOKEN</span>)<br>  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">path</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/main&#x27;</span>) &amp;&amp; !token) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;/login&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="1-1-1-退出登录功能"><a href="#1-1-1-退出登录功能" class="headerlink" title="1.1.1 退出登录功能"></a>1.1.1 退出登录功能</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 清除缓存 -&gt; 跳转到 login</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleExitClick</span>(<span class="hljs-params"></span>) &#123;<br>  localCache.<span class="hljs-title function_">removeCache</span>(<span class="hljs-variable constant_">LOGIN_TOKEN</span>)<br>  router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/login&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-记住密码功能"><a href="#1-2-记住密码功能" class="headerlink" title="1.2. 记住密码功能"></a>1.2. 记住密码功能</h3><h3 id="1-3-main权限管理"><a href="#1-3-main权限管理" class="headerlink" title="1.3. main权限管理"></a>1.3. main权限管理</h3><ul><li>RBAC: role based access control<ul><li>基于角色访问控制(权限管理)</li></ul></li><li>后台数据库设计表(了解)</li></ul><h3 id="1-4-请求用户信息"><a href="#1-4-请求用户信息" class="headerlink" title="1.4. 请求用户信息"></a>1.4. 请求用户信息</h3><ul><li>用户的角色</li></ul><h3 id="1-5-根据角色id获取菜单信息"><a href="#1-5-根据角色id获取菜单信息" class="headerlink" title="1.5. 根据角色id获取菜单信息"></a>1.5. 根据角色id获取菜单信息</h3><h3 id="1-6-userInfo-x2F-userMenus进行本地缓存"><a href="#1-6-userInfo-x2F-userMenus进行本地缓存" class="headerlink" title="1.6. userInfo&#x2F;userMenus进行本地缓存"></a>1.6. userInfo&#x2F;userMenus进行本地缓存</h3><h2 id="二-首页的界面搭建"><a href="#二-首页的界面搭建" class="headerlink" title="二. 首页的界面搭建"></a>二. 首页的界面搭建</h2><h3 id="2-1-整体的布局ElContainer"><a href="#2-1-整体的布局ElContainer" class="headerlink" title="2.1. 整体的布局ElContainer"></a>2.1. 整体的布局ElContainer</h3><h3 id="2-2-侧边栏的菜单Menu"><a href="#2-2-侧边栏的菜单Menu" class="headerlink" title="2.2. 侧边栏的菜单Menu"></a>2.2. 侧边栏的菜单Menu</h3><h4 id="2-2-1-分析ElMenu每一个组件的作用"><a href="#2-2-1-分析ElMenu每一个组件的作用" class="headerlink" title="2.2.1. 分析ElMenu每一个组件的作用"></a>2.2.1. 分析ElMenu每一个组件的作用</h4><h4 id="2-2-2-手动的搭建整个菜单结构"><a href="#2-2-2-手动的搭建整个菜单结构" class="headerlink" title="2.2.2. 手动的搭建整个菜单结构"></a>2.2.2. 手动的搭建整个菜单结构</h4><h4 id="2-2-3-根据userMenus动态遍历"><a href="#2-2-3-根据userMenus动态遍历" class="headerlink" title="2.2.3. 根据userMenus动态遍历"></a>2.2.3. 根据userMenus动态遍历</h4><h4 id="2-2-4-图标动态-动态组件"><a href="#2-2-4-图标动态-动态组件" class="headerlink" title="2.2.4. 图标动态: 动态组件"></a>2.2.4. 图标动态: 动态组件</h4><h3 id="2-3-Main的头部Header展示"><a href="#2-3-Main的头部Header展示" class="headerlink" title="2.3. Main的头部Header展示"></a>2.3. Main的头部Header展示</h3><h4 id="2-3-1-menu-icon的图标点击"><a href="#2-3-1-menu-icon的图标点击" class="headerlink" title="2.3.1. menu-icon的图标点击"></a>2.3.1. menu-icon的图标点击</h4><ul><li>点击切换自己的图标</li><li>切换aside的宽度(动画)</li><li>切换menu的折叠效果</li></ul><h4 id="2-3-2-个人信息的展示"><a href="#2-3-2-个人信息的展示" class="headerlink" title="2.3.2. 个人信息的展示"></a>2.3.2. 个人信息的展示</h4><ul><li>退出登录</li><li>样式的调整</li></ul><h3 id="2-4-注册所有的路由-页面跳转（动态路由）"><a href="#2-4-注册所有的路由-页面跳转（动态路由）" class="headerlink" title="2.4. 注册所有的路由, 页面跳转（动态路由）"></a>2.4. 注册所有的路由, 页面跳转（动态路由）</h3><ul><li>动态的菜单进行权限管理</li><li>但是所有的路由都是被注册进去</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端项目</category>
      
      <category>CMS 项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>elementUI 与搭建登录页面</title>
    <link href="/2023/03/7cfa452e70c6.html"/>
    <url>/2023/03/7cfa452e70c6.html</url>
    
    <content type="html"><![CDATA[<h2 id="一-Element-Plus集成"><a href="#一-Element-Plus集成" class="headerlink" title="一. Element-Plus集成"></a>一. Element-Plus集成</h2><h3 id="1-1-全局引入"><a href="#1-1-全局引入" class="headerlink" title="1.1. 全局引入"></a>1.1. 全局引入</h3><ul><li>“types”: [“element-plus&#x2F;global”] 的配置，可以使用 volar 提示 props</li></ul><h3 id="1-2-按需引入"><a href="#1-2-按需引入" class="headerlink" title="1.2. 按需引入(*)"></a>1.2. 按需引入(*)</h3><ul><li><p>vite插件配置</p><p><a href="http://element-plus.org/zh-CN/guide/quickstart.html#%E6%8C%89%E9%9C%80%E5%AF%BC%E5%85%A5">http://element-plus.org/zh-CN/guide/quickstart.html#%E6%8C%89%E9%9C%80%E5%AF%BC%E5%85%A5</a></p></li></ul><h3 id="1-3-图标的引入"><a href="#1-3-图标的引入" class="headerlink" title="1.3. 图标的引入"></a>1.3. 图标的引入</h3><h3 id="1-4-ElMessage引入"><a href="#1-4-ElMessage引入" class="headerlink" title="1.4. ElMessage引入"></a>1.4. ElMessage引入</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> registerIcons <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./global/register-icons&#x27;</span><br><br><span class="hljs-comment">// 0.针对ElMessage和ElLoading等组件引入样式</span><br><span class="hljs-comment">// 1.全局引入样式(所有样式全部引入)</span><br><span class="hljs-comment">// import &#x27;element-plus/dist/index.css&#x27;</span><br><span class="hljs-comment">// 2.组件样式引入</span><br><span class="hljs-comment">// import &#x27;element-plus/theme-chalk/el-message.css&#x27;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 3.使用vite-plugin-style-import</span><br><span class="hljs-comment"> *   * npm install vite-plugin-style-import consola -D</span><br><span class="hljs-comment"> *   * 在vite.config.ts中配置</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 1.全局注册element-plus: 方便和简洁</span><br><span class="hljs-comment">// import ElementPlus from &#x27;element-plus&#x27;</span><br><span class="hljs-comment">// import &#x27;element-plus/dist/index.css&#x27;</span><br><br><span class="hljs-comment">// app.use(ElementPlus)</span><br><br><span class="hljs-comment">// 2.按需引入: 用到哪一个组件再引入</span><br><span class="hljs-comment">// import &#123; ElButton &#125; from &#x27;element-plus&#x27;</span><br><span class="hljs-comment">// app.component(ElButton.name, ElButton)</span><br><br><span class="hljs-comment">// 3.图标的全局注册</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br>app.<span class="hljs-title function_">use</span>(registerIcons)<br></code></pre></td></tr></table></figure><h2 id="二-搭建登录页面"><a href="#二-搭建登录页面" class="headerlink" title="二. 搭建登录页面"></a>二. 搭建登录页面</h2><h3 id="2-1-背景的搭建"><a href="#2-1-背景的搭建" class="headerlink" title="2.1. 背景的搭建"></a>2.1. 背景的搭建</h3><ul><li>100vw&#x2F;vh</li></ul><h3 id="2-2-登录界面Panel"><a href="#2-2-登录界面Panel" class="headerlink" title="2.2. 登录界面Panel"></a>2.2. 登录界面Panel</h3><h4 id="2-2-1-整体界面的搭建"><a href="#2-2-1-整体界面的搭建" class="headerlink" title="2.2.1. 整体界面的搭建"></a>2.2.1. 整体界面的搭建</h4><ul><li>标题</li><li>tabs</li><li>记住密码&#x2F;忘记链接(组件)</li><li>立即登录(组件)</li></ul><h4 id="2-2-2-tabs搭建过程"><a href="#2-2-2-tabs搭建过程" class="headerlink" title="2.2.2. tabs搭建过程"></a>2.2.2. tabs搭建过程</h4><ul><li>label的插槽使用</li><li>内容显示</li></ul><h4 id="2-2-3-账号登录form"><a href="#2-2-3-账号登录form" class="headerlink" title="2.2.3. 账号登录form"></a>2.2.3. 账号登录form</h4><ul><li>ElForm&#x2F;ElFormItem&#x2F;ElInput</li><li>绑定属性</li></ul><h4 id="2-2-4-form的校验规则"><a href="#2-2-4-form的校验规则" class="headerlink" title="2.2.4. form的校验规则"></a>2.2.4. form的校验规则</h4><h4 id="2-2-5-点击立即登录"><a href="#2-2-5-点击立即登录" class="headerlink" title="2.2.5. 点击立即登录"></a>2.2.5. 点击立即登录</h4><ul><li>父组件发生点击, 执行子组件的函数.</li><li>defineExpose()： 用于定义暴露给全局作用域的变量</li><li>const accountRef &#x3D; ref&lt;InstanceType<typeof PaneAccount>&gt;()</li></ul><h3 id="2-3-登录的操作"><a href="#2-3-登录的操作" class="headerlink" title="2.3. 登录的操作"></a>2.3. 登录的操作</h3><h4 id="2-3-1-form通过验证"><a href="#2-3-1-form通过验证" class="headerlink" title="2.3.1. form通过验证"></a>2.3.1. form通过验证</h4><ul><li>formRef.validate(回调)</li></ul><h4 id="2-3-2-登录接口的调用"><a href="#2-3-2-登录接口的调用" class="headerlink" title="2.3.2. 登录接口的调用"></a>2.3.2. 登录接口的调用</h4><ul><li>post</li><li>data: {name, password}</li></ul><h4 id="2-3-3-将登录操作store中"><a href="#2-3-3-将登录操作store中" class="headerlink" title="2.3.3. 将登录操作store中"></a>2.3.3. 将登录操作store中</h4><h4 id="2-3-4-IAccount类型的定义"><a href="#2-3-4-IAccount类型的定义" class="headerlink" title="2.3.4. IAccount类型的定义"></a>2.3.4. IAccount类型的定义</h4><h3 id="2-4-postman的使用"><a href="#2-4-postman的使用" class="headerlink" title="2.4. postman的使用"></a>2.4. postman的使用</h3><h3 id="2-5-token缓存和cache封装"><a href="#2-5-token缓存和cache封装" class="headerlink" title="2.5. token缓存和cache封装"></a>2.5. token缓存和cache封装</h3>]]></content>
    
    
    <categories>
      
      <category>前端项目</category>
      
      <category>CMS 项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>axios</title>
    <link href="/2023/03/c6ffc7ae2247.html"/>
    <url>/2023/03/c6ffc7ae2247.html</url>
    
    <content type="html"><![CDATA[<h1 id="网络请求库-–-axios库"><a href="#网络请求库-–-axios库" class="headerlink" title="网络请求库 – axios库"></a>网络请求库 – axios库</h1><h2 id="认识axios"><a href="#认识axios" class="headerlink" title="认识axios"></a>认识axios</h2><p><img src="http://rrk0fj71q.hn-bkt.clouddn.com/image-20230315224344076.png" alt="image-20230315224344076"></p><h2 id="axios请求方式"><a href="#axios请求方式" class="headerlink" title="axios请求方式"></a>axios请求方式</h2><p><img src="http://rrk0fj71q.hn-bkt.clouddn.com/image-20230316131343485.png" alt="image-20230316131343485"></p><h2 id="常见的配置选项"><a href="#常见的配置选项" class="headerlink" title="常见的配置选项"></a>常见的配置选项</h2><p><img src="http://rrk0fj71q.hn-bkt.clouddn.com/image-20230316131542711.png" alt="image-20230316131542711"></p><h2 id="axios的创建实例"><a href="#axios的创建实例" class="headerlink" title="axios的创建实例"></a>axios的创建实例</h2><p><img src="http://rrk0fj71q.hn-bkt.clouddn.com/image-20230316133936328.png" alt="image-20230316133936328"></p><h2 id="请求和响应拦截器"><a href="#请求和响应拦截器" class="headerlink" title="请求和响应拦截器"></a>请求和响应拦截器</h2><p><img src="http://rrk0fj71q.hn-bkt.clouddn.com/image-20230316134035896.png" alt="image-20230316134035896"></p><p>用处1：通过请求和响应拦截器加载 <code>loading</code>动画</p><p>用处 2：对 <code>请求参数 </code>的修改，token cookie</p><h2 id="axios请求库封装-降低项目对-axios-库的耦合度"><a href="#axios请求库封装-降低项目对-axios-库的耦合度" class="headerlink" title="axios请求库封装(降低项目对 axios 库的耦合度)"></a>axios请求库封装(降低项目对 axios 库的耦合度)</h2><p><img src="http://rrk0fj71q.hn-bkt.clouddn.com/image-20230316141720842.png" alt="image-20230316141720842"></p><p>typescript 封装： <a href="https://juejin.cn/post/7071518211392405541">在项目中用ts封装axios，一次封装整个团队受益😁 - 掘金 (juejin.cn)</a></p><ul><li>类拦截器 （类内部的拦截，aka 通用拦截）</li><li>实例拦截器（针对不同实例的拦截，创建实例的时候传入不同的拦截器实现不同的效果（如 loading））</li><li>接口拦截器（对每个请求做精细化的控制）</li></ul>]]></content>
    
    
    <categories>
      
      <category>dev</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CMS 项目文档</title>
    <link href="/2023/03/b218196c82cd.html"/>
    <url>/2023/03/b218196c82cd.html</url>
    
    <content type="html"><![CDATA[<h1 id="每个配置文件的作用"><a href="#每个配置文件的作用" class="headerlink" title="每个配置文件的作用"></a>每个配置文件的作用</h1><ol><li><code>vite.config.ts</code>: 用于配置项目的构建选项和开发服务器选项, 配置插件、别名、CSS 预处理器等选项，以满足不同项目的需求。</li><li><code>tsconfig.json</code>: 用于配置项目的 TypeScript 编译选项，包括编译器的选项、编译输出的目录、编译的文件等。</li><li><code>env.d.ts</code>: 是一个声明文件，用于声明 TypeScript 中使用的全局变量的类型。在 Vue 3 项目中，<code>env.d.ts</code> 文件通常位于项目的根目录下，用于声明项目中使用的环境变量的类型。</li><li><code>.eslintrc.cjs</code>: 代码规范</li><li><code>editorconfig</code>: 代码规范</li></ol><h1 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h1><p>baseURL的值：</p><p><a href="http://152.136.185.210:5000/">http://152.136.185.210:5000</a><br><a href="http://152.136.185.210:4000/">http://152.136.185.210:4000</a></p><p>设置全局token的方法：</p><p><code>const res = pm.response.json(); </code> </p><p><code>pm.globals.set(&quot;token&quot;, res.data.token);</code></p><p>接口文档v2版本：（有部分更新）</p><p><a href="https://documenter.getpostman.com/view/12387168/TzzDKb12">https://documenter.getpostman.com/view/12387168/TzzDKb12</a></p><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><h4 id="1-目录结构的创建"><a href="#1-目录结构的创建" class="headerlink" title="1. 目录结构的创建"></a>1. 目录结构的创建</h4><h4 id="2-css样式的重置"><a href="#2-css样式的重置" class="headerlink" title="2. css样式的重置"></a>2. css样式的重置</h4><h4 id="3-vue-router路由"><a href="#3-vue-router路由" class="headerlink" title="3. vue-router路由"></a>3. vue-router路由</h4><h4 id="4-pinia状态管理"><a href="#4-pinia状态管理" class="headerlink" title="4. pinia状态管理"></a>4. pinia状态管理</h4><h4 id="5-axios网络请求（-）"><a href="#5-axios网络请求（-）" class="headerlink" title="5. axios网络请求（*）"></a>5. axios网络请求（*）</h4><h4 id="6-区分开发和生产环境"><a href="#6-区分开发和生产环境" class="headerlink" title="6. 区分开发和生产环境"></a>6. 区分开发和生产环境</h4>]]></content>
    
    
    <categories>
      
      <category>前端项目</category>
      
      <category>CMS 项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
